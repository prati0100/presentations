#+title: Userspace memory persistence over kexec
#+author: Pratyush Yadav <pratyush@kernel.org>
#+options: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+options: H:2 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t date:nil
#+latex_class: beamer
#+latex_class_options: [presentation]
#+beamer_header: \setbeamerfont{institute}{size=\normalsize}
#+beamer_header: \institute{Amazon Web Services}
#+beamer_header: \setbeamertemplate{frametitle continuation}{}
#+exclude_tags: noexport

#+name: setup-minted
#+begin_src emacs-lisp :exports results :results silent
(setq org-latex-src-block-backend 'minted)
(add-to-list 'org-latex-packages-alist '("" "minted" nil))
(setq org-latex-minted-options '(("frame" "single")))
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+end_src

* Agenda
:PROPERTIES:
:not-in-toc:
:BEAMER_env: frame
:END:
#+beamer: \tableofcontents

* Why?
** Agenda
#+beamer: \tableofcontents[current]

** Why?
#+attr_beamer: :overlay <+->
- You need to reboot to apply kernel patches.
- For stateless hosts this isn't a big problem.
- It is a bigger problem for stateful hosts like database servers or storage
  nodes.
  - <1->Can't just spin up a new host.
  - <1->Availability risks.
- Also useful if you don't control underlying workload.

* How?
** Agenda
#+beamer: \tableofcontents[current]

** How?
- Allow handing over userspace memory over kexec.
- Applications aware of being kexec-ed can serialize/deserialize state.
- For unaware applications, we can use Checkpoint/Restore in Userspace (CRIU).

** How?
#+beamer: \includegraphics<1>[width=\textwidth,page=1]{lpc_2024_final.pdf}
#+beamer: \includegraphics<2>[width=\textwidth,page=2]{lpc_2024_final.pdf}
#+beamer: \includegraphics<3>[width=\textwidth,page=3]{lpc_2024_final.pdf}
#+beamer: \includegraphics<4>[width=\textwidth,page=4]{lpc_2024_final.pdf}
#+beamer: \includegraphics<5>[width=\textwidth,page=5]{lpc_2024_final.pdf}
#+beamer: \includegraphics<6>[width=\textwidth,page=6]{lpc_2024_final.pdf}
#+beamer: \includegraphics<7>[width=\textwidth,page=7]{lpc_2024_final.pdf}

* API
** Agenda
#+beamer: \tableofcontents[current]

** API
A new system call named ~kmho()~ with two modes of operation: take over memory
and hand over memory.

#+begin_src c
int kmho(unsigned int opcode, void *op);
#+end_src

** API
For handing over memory (before kexec), one can call the ~KMHO_HANDOVER~
operation. ~op~ should be a ~struct kmho_op_handover~.

#+begin_src c
struct kmho_range_handover {
	unsigned long base;
	unsigned long length;
};

struct kmho_op_handover {
	unsigned long key;
	unsigned long num_ranges;
	struct kmho_range_handover *ranges;
};
#+end_src

** API
An example call would look like:

#+begin_src c
struct kmho_range_handover range = {
	.base = base,
	.length = len,
};

struct kmho_op_handover op = {
	.key = 0xabcd1234,
	.num_ranges = 1,
	.ranges = &range,
};
kmho(KMHO_HANDOVER, &op);
#+end_src

** API
For taking over memory (after kexec), one can call the ~KMHO_TAKEOVER~
operation. ~op~ should be a ~struct kmho_op_takeover~.

#+begin_src c
struct kmho_range_takeover {
	unsigned long base;
	unsigned long len;
	unsigned long remap_addr;
};

struct kmho_op_takeover {
	unsigned long key;
	unsigned long num_ranges;
	struct kmho_range_takeover *ranges;
};
#+end_src

** API
An example call would look like:

#+begin_src c
struct kmho_range_takeover range = {
	.base = base, // memory addr during handover
	.length = len,
	.remap_addr = new_addr, // New addr to map to
};

struct kmho_op_takeover op = {
	.key = 0xabcd1234,
	.num_ranges = 1,
	.ranges = &range,
};
kmho(KMHO_TAKEOVER, &op);
#+end_src

* Implementation details
** Agenda
#+beamer: \tableofcontents[current]

** Handover
#+begin_src c
for_each_page() {
	folio_get(folio);
        do_munmap(mm, addr, PAGE_SIZE, NULL);
        lruvec_del_folio(lruvec, folio);
        mem_cgroup_uncharge(folio);
}
#+end_src

** Takeover
#+begin_src c
for_each_page() {
        anon_vma_prepare(vma);
        mk_pte(page, page_prot);
        mem_cgroup_charge(folio, mm, GFP_KERNEL);
        inc_mm_counter(mm, MM_ANONPAGES);
	folio_add_new_anon_rmap(folio, vma, addr);
	folio_add_lru_vma(folio, vma);
	set_ptes(mm, addr, ptep, entry, 1);
}
#+end_src

* Current state
** Agenda
#+beamer: \tableofcontents[current]

** Current state
- Implemented proof-of-concept using system call.
- Some hacky patches for CRIU to use this functionality.
- Plan to send out RFC soon.

** Demo!
https://asciinema.org/a/3LZjzIe53Uvdhi7GenUxakrqy

* Future extensions
** Agenda
#+beamer: \tableofcontents[current]

** Future extensions
- Handover swap contents across kexec.
- Handover page cache across kexec.

* :B_frame:
:PROPERTIES:
:not-in-toc:
:BEAMER_env: frame
:END:

#+beamer: \begin{center}
#+beamer: \Huge Thank you for attending the talk!
#+beamer: \end{center}

* :B_frame:
:PROPERTIES:
:not-in-toc:
:BEAMER_env: frame
:END:

* FAQs
:PROPERTIES:
:UNNUMBERED: t
:END:

** Why not implement it via an in-memory filesystem?
An in-memory file system that survives kexec has been proposed in the past. It
has some drawbacks though.

Pros:
- Won't need some of the tricky logic to unmap anonymous pages without freeing
  them. Can directly use the ~mmap()~ machinery.
- Since we are dealing with memory, makes more sense to treat it like memory
  instead of file.

Cons:
- You need something to manage/garbage collect the files on the FS.

** What about fragmentation?
- Yes, if you use ~kmho()~ the new kernel gets the old kernel's fragmentation.
- But that is an independent problem.
- We should solve that regardless of whether you use ~kmho()~ or not.

** Do we really need a new system call?
- We can overload ~mmap()~, ~munmap()~, and ~mremap()~ to do this.
- This makes interface of these system calls more complex.
- Having a new system call keeps things nicely separated, and leaves more room
  for growth later.
